<div class="card">
    <h3 class="card-title mb-3">Table of Contents</h3>
    <nav id="toc" class="text-sm max-h-[65vh] overflow-y-auto custom-scrollbar space-y-1">
        <!-- TOC Generated by JS -->
    </nav>
</div>

<style>
    /* Custom Scrollbar for TOC */
    .custom-scrollbar::-webkit-scrollbar {
        width: 4px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 20px;
    }

    .dark .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #475569;
    }

    #toc a {
        display: block;
        line-height: 1.4;
        padding-top: 0.25rem;
        padding-bottom: 0.25rem;
        border-left: 2px solid transparent;
    }

    #toc a.active {
        color: #2563eb;
        /* blue-600 */
        border-left-color: #2563eb;
        background-color: rgba(37, 99, 235, 0.05);
    }

    .dark #toc a.active {
        color: #60a5fa;
        /* blue-400 */
        border-left-color: #60a5fa;
        background-color: rgba(96, 165, 250, 0.1);
    }
</style>

<script>
    (function () {
        // --- ScrollSpy Logic variables (scoped to IIFE) ---
        let isManualScrolling = false; // Flag to prevent observer updates during manual scroll
        let manualScrollTimeout; // Timeout for releasing manual scroll lock
        let observer; // Intersection Observer instance

        function initTOC() {
            const tocContainer = document.getElementById('toc');
            const contentBody = document.querySelector('.content-body');

            // Check if elements exist; if not, retry slightly later or give up
            // (Useful if script runs before DOM is fully parsed, though inline script usually effectively blocks until parsed)
            if (!tocContainer || !contentBody) return;

            // Prevent duplicate TOC generation if already populated
            if (tocContainer.children.length > 0 && tocContainer.querySelector('a')) return;

            const headings = contentBody.querySelectorAll('h1, h2, h3, h4, h5, h6');
            if (headings.length === 0) {
                tocContainer.closest('.card').style.display = 'none';
                return;
            }

            const tocList = document.createElement('div');
            tocList.className = 'flex flex-col';

            headings.forEach((heading, index) => {
                // Ensure heading has an id
                if (!heading.id) {
                    const slug = heading.textContent
                        .toLowerCase()
                        .replace(/[^\w\s-]/g, '')
                        .trim()
                        .replace(/[\s-]+/g, '-')
                        .replace(/^-+|-+$/g, '');
                    heading.id = slug || `heading-${index}`;
                }

                const link = document.createElement('a');
                link.href = `#${heading.id}`;

                // LOGIC RESCUE: Use innerHTML to preserve MathJax delimeters (e.g. @...@)
                // We must strip any existing <a> tags inside the heading to avoid nested links
                const clone = heading.cloneNode(true);
                const anchors = clone.querySelectorAll('a');
                anchors.forEach(a => a.remove());

                link.innerHTML = clone.innerHTML;

                // Styling
                // Changed text-gray-600 to text-gray-900 for darker text in light mode
                link.className = 'text-main hover:text-blue-600 dark:hover:text-blue-400 truncate pr-2';

                // Indentation logic
                const level = parseInt(heading.tagName.charAt(1)); // h2 -> 2
                // Base indentation (can be adjusted)
                const indent = Math.max(0, (level - 1) * 16); // 16px per level step
                link.style.paddingLeft = `${indent + 8}px`; // +8px base padding

                // Click handling for smooth scroll
                link.addEventListener('click', (e) => {
                    e.preventDefault();

                    // Lock the observer during manual scroll
                    isManualScrolling = true;
                    clearTimeout(manualScrollTimeout);

                    // Manual override: Set active immediately
                    document.querySelectorAll('#toc a').forEach(a => a.classList.remove('active'));
                    link.classList.add('active');

                    // Use the heading element reference directly
                    if (heading) {
                        const headerOffset = 80;
                        const elementPosition = heading.getBoundingClientRect().top;
                        const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

                        window.scrollTo({
                            top: offsetPosition,
                            behavior: 'smooth'
                        });

                        // Update URL hash without jump
                        history.pushState(null, null, `#${heading.id}`);

                        // Release lock after animation
                        manualScrollTimeout = setTimeout(() => {
                            isManualScrolling = false;
                            updateActiveHeader(); // Re-evaluate active header after manual scroll
                        }, 1000);
                    }
                });

                tocList.appendChild(link);
            });

            tocContainer.appendChild(tocList);

            // Initial MathJax Typesetting for the TOC
            if (window.MathJax) {
                MathJax.typesetPromise([tocContainer]).catch(err => console.log('MathJax TOC error:', err));
            }

            // Setup Observer
            setupObserver(headings);
        }

        // --- ScrollSpy Logic functions ---

        function setupObserver(headings) {
            // Disconnect existing observer if it exists to prevent multiple observers
            if (observer) observer.disconnect();

            // State to track which headers are currently visible
            const visibleHeaders = new Map();

            function updateActiveHeader() {
                // If we are manually scrolling, do not update automatically
                if (isManualScrolling) return;

                // Find the first visible header (in DOM order)
                // Since 'headings' is a NodeList in DOM order, we can iterate it.
                let activeHeaderId = null;

                // Check which is the first one in our visible map
                for (const heading of headings) {
                    if (visibleHeaders.get(heading.id)) {
                        activeHeaderId = heading.id;
                        break; // Found the topmost visible header
                    }
                }

                // If no header is "visible" by observer standards (e.g. all scrolled up),
                // we might want to keep the last active one, or find the one just above the viewport.
                // For now, let's stick to the first visible one.

                if (activeHeaderId) {
                    setActiveLink(activeHeaderId);
                }
            }

            function setActiveLink(id) {
                const tocContainer = document.getElementById('toc');
                if (!tocContainer) return; // Ensure tocContainer exists

                document.querySelectorAll('#toc a').forEach(a => {
                    const isActive = a.getAttribute('href') === `#${id}`;
                    if (isActive) {
                        a.classList.add('active');
                        // Auto-scroll TOC
                        const tocRect = tocContainer.getBoundingClientRect();
                        const linkRect = a.getBoundingClientRect();
                        if (linkRect.top < tocRect.top || linkRect.bottom > tocRect.bottom) {
                            a.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                        }
                    } else {
                        a.classList.remove('active');
                    }
                });
            }

            observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    visibleHeaders.set(entry.target.id, entry.isIntersecting);
                });
                updateActiveHeader();
            }, {
                // Adjust rootMargin to focus on the top area of the screen
                // '0px 0px -85% 0px' means we only care about the top 15% of the viewport
                rootMargin: '-70px 0px -85% 0px'
            });

            headings.forEach(h => observer.observe(h));
        }

        // Initialize on various events
        document.addEventListener('DOMContentLoaded', initTOC);
        document.addEventListener('turbo:load', initTOC);
        // Also run immediately in case we missed events (e.g., script loaded after DOMContentLoaded)
        initTOC();

    })();
</script>